/**
 * COMPLETE SUPABASE DATABASE ANALYSIS
 * ===================================
 * Comprehensive analysis of current database state including:
 * - All tables and their schemas
 * - Row Level Security (RLS) policies
 * - Indexes and constraints
 * - Current data counts
 * - Missing tables identification
 */

const { createClient } = require('@supabase/supabase-js')
const fs = require('fs')
require('dotenv').config({ path: '.env.local' })

// Use service role for full database access
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
)

async function analyzeCompleteDatabase() {
  console.log('üîç COMPLETE SUPABASE DATABASE ANALYSIS')
  console.log('=====================================')
  console.log(`üì° Connected to: ${process.env.NEXT_PUBLIC_SUPABASE_URL}`)
  console.log(`‚è∞ Analysis started: ${new Date().toISOString()}`)
  console.log('')

  const analysis = {
    connection: {},
    tables: {},
    policies: {},
    indexes: {},
    functions: {},
    data_counts: {},
    missing_tables: [],
    recommendations: []
  }

  try {
    // ===========================
    // 1. TEST DATABASE CONNECTION
    // ===========================
    console.log('1Ô∏è‚É£ TESTING DATABASE CONNECTION')
    console.log('==============================')
    
    const { data: testData, error: testError } = await supabase
      .from('users')
      .select('count')
      .limit(1)
    
    if (testError) {
      console.log('‚ùå Connection failed:', testError.message)
      analysis.connection = { status: 'failed', error: testError.message }
      return analysis
    }
    
    console.log('‚úÖ Database connection successful')
    analysis.connection = { status: 'connected', url: process.env.NEXT_PUBLIC_SUPABASE_URL }

    // ===========================
    // 2. DISCOVER ALL TABLES
    // ===========================
    console.log('\n2Ô∏è‚É£ DISCOVERING ALL TABLES')
    console.log('==========================')
    
    // Try multiple methods to get table information
    let tables = []
    
    // Method 1: Query information_schema (PostgreSQL standard)
    try {
      const { data: schemaData, error: schemaError } = await supabase
        .rpc('get_table_info')
      
      if (!schemaError && schemaData) {
        tables = schemaData
        console.log('‚úÖ Retrieved table info via custom function')
      }
    } catch (err) {
      console.log('‚ö†Ô∏è Custom function not available, trying direct query...')
    }
    
    // Method 2: Direct information_schema query
    if (tables.length === 0) {
      try {
        const { data: directData, error: directError } = await supabase
          .from('information_schema.tables')
          .select('*')
          .eq('table_schema', 'public')
        
        if (!directError && directData) {
          tables = directData.map(t => ({ table_name: t.table_name }))
          console.log('‚úÖ Retrieved table info via information_schema')
        }
      } catch (err) {
        console.log('‚ö†Ô∏è Direct schema query failed, using table discovery...')
      }
    }
    
    // Method 3: Try known tables individually
    if (tables.length === 0) {
      const knownTables = [
        'users', 'restaurants', 'menu_items', 'orders', 'order_items',
        'notifications', 'delivery_zones', 'support_tickets', 'payment_transactions',
        'delivery_assignments', 'rider_documents', 'restaurant_documents',
        'admin_permissions', 'system_settings', 'rider_guarantors', 'payout_history'
      ]
      
      console.log('üîç Testing known tables individually...')
      for (const tableName of knownTables) {
        try {
          const { error } = await supabase
            .from(tableName)
            .select('*')
            .limit(1)
          
          if (!error) {
            tables.push({ table_name: tableName })
            console.log(`‚úÖ Found: ${tableName}`)
          } else {
            console.log(`‚ùå Missing: ${tableName}`)
            analysis.missing_tables.push(tableName)
          }
        } catch (err) {
          console.log(`‚ùå Error testing ${tableName}:`, err.message)
        }
      }
    }
    
    analysis.tables = tables.reduce((acc, table) => {
      acc[table.table_name] = { exists: true }
      return acc
    }, {})

    // ===========================
    // 3. GET DATA COUNTS
    // ===========================
    console.log('\n3Ô∏è‚É£ COUNTING DATA IN EACH TABLE')
    console.log('===============================')
    
    for (const table of tables) {
      try {
        const { count, error } = await supabase
          .from(table.table_name)
          .select('*', { count: 'exact', head: true })
        
        if (!error) {
          console.log(`üìä ${table.table_name}: ${count} rows`)
          analysis.data_counts[table.table_name] = count
          analysis.tables[table.table_name].row_count = count
        } else {
          console.log(`‚ùå ${table.table_name}: Could not count (${error.message})`)
          analysis.tables[table.table_name].row_count = 'unknown'
        }
      } catch (err) {
        console.log(`‚ùå ${table.table_name}: Error counting (${err.message})`)
      }
    }

    // ===========================
    // 4. CHECK RLS STATUS
    // ===========================
    console.log('\n4Ô∏è‚É£ CHECKING ROW LEVEL SECURITY (RLS)')
    console.log('====================================')
    
    try {
      // Try to check RLS status using a SQL query
      const { data: rlsData, error: rlsError } = await supabase
        .rpc('check_rls_status')
      
      if (!rlsError && rlsData) {
        console.log('üìã RLS Status from custom function:')
        rlsData.forEach(table => {
          const status = table.rls_enabled ? 'üîí Enabled' : 'üîì Disabled'
          console.log(`  ${table.table_name}: ${status}`)
          analysis.policies[table.table_name] = {
            rls_enabled: table.rls_enabled,
            policies: table.policies || []
          }
        })
      } else {
        console.log('‚ö†Ô∏è Cannot check RLS status - will test tables individually')
        
        // Test RLS by attempting queries
        for (const table of tables) {
          try {
            // Try with anon client to see if RLS blocks
            const anonClient = createClient(
              process.env.NEXT_PUBLIC_SUPABASE_URL,
              process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
            )
            
            const { error: anonError } = await anonClient
              .from(table.table_name)
              .select('*')
              .limit(1)
            
            const rlsStatus = anonError && anonError.message.includes('row-level security') ? 'enabled' : 'disabled'
            console.log(`  ${table.table_name}: RLS ${rlsStatus}`)
            analysis.policies[table.table_name] = { rls_enabled: rlsStatus === 'enabled' }
          } catch (err) {
            console.log(`  ${table.table_name}: Could not test RLS`)
          }
        }
      }
    } catch (err) {
      console.log('‚ùå RLS check failed:', err.message)
    }

    // ===========================
    // 5. SAMPLE DATA FROM KEY TABLES
    // ===========================
    console.log('\n5Ô∏è‚É£ SAMPLING KEY TABLE DATA')
    console.log('===========================')
    
    const keyTables = ['users', 'restaurants', 'menu_items', 'orders']
    
    for (const tableName of keyTables) {
      if (analysis.tables[tableName]) {
        try {
          const { data, error } = await supabase
            .from(tableName)
            .select('*')
            .limit(3)
          
          if (!error && data) {
            console.log(`\nüìã Sample from ${tableName}:`)
            data.forEach((row, index) => {
              console.log(`  Row ${index + 1}:`, Object.keys(row).slice(0, 5).map(key => `${key}: ${row[key]}`).join(', '))
            })
            analysis.tables[tableName].sample_data = data.slice(0, 2) // Store 2 samples
          }
        } catch (err) {
          console.log(`‚ùå Could not sample ${tableName}:`, err.message)
        }
      }
    }

    // ===========================
    // 6. IDENTIFY MISSING TABLES
    // ===========================
    console.log('\n6Ô∏è‚É£ IDENTIFYING MISSING CRITICAL TABLES')
    console.log('======================================')
    
    const requiredTables = [
      'notifications', 'delivery_zones', 'support_tickets', 'payment_transactions',
      'delivery_assignments', 'rider_documents', 'restaurant_documents',
      'admin_permissions', 'system_settings', 'rider_guarantors', 'payout_history'
    ]
    
    const missingTables = requiredTables.filter(tableName => !analysis.tables[tableName])
    
    if (missingTables.length > 0) {
      console.log('‚ùå Missing critical tables:')
      missingTables.forEach(table => {
        console.log(`  - ${table}`)
        analysis.missing_tables.push(table)
      })
    } else {
      console.log('‚úÖ All critical tables exist')
    }

    // ===========================
    // 7. CHECK EXISTING TABLE SCHEMAS
    // ===========================
    console.log('\n7Ô∏è‚É£ CHECKING EXISTING TABLE SCHEMAS')
    console.log('===================================')
    
    for (const tableName of ['users', 'restaurants', 'menu_items', 'orders', 'order_items']) {
      if (analysis.tables[tableName]) {
        try {
          const { data, error } = await supabase
            .from(tableName)
            .select('*')
            .limit(1)
          
          if (!error && data && data[0]) {
            const columns = Object.keys(data[0])
            console.log(`üìã ${tableName} columns:`, columns.join(', '))
            analysis.tables[tableName].columns = columns
          }
        } catch (err) {
          console.log(`‚ùå Could not analyze ${tableName} schema`)
        }
      }
    }

    // ===========================
    // 8. GENERATE RECOMMENDATIONS
    // ===========================
    console.log('\n8Ô∏è‚É£ GENERATING RECOMMENDATIONS')
    console.log('==============================')
    
    // Check for critical missing features
    if (analysis.missing_tables.length > 0) {
      analysis.recommendations.push('üö® URGENT: Create missing tables for core functionality')
    }
    
    if (!analysis.policies['users']?.rls_enabled) {
      analysis.recommendations.push('üîí SECURITY: Enable RLS on users table')
    }
    
    if (!analysis.policies['orders']?.rls_enabled) {
      analysis.recommendations.push('üîí SECURITY: Enable RLS on orders table')
    }
    
    if (analysis.data_counts['users'] > 0 && analysis.missing_tables.includes('notifications')) {
      analysis.recommendations.push('üìß CUSTOMER EXPERIENCE: Create notifications table for user communication')
    }
    
    analysis.recommendations.forEach(rec => console.log(rec))

    // ===========================
    // 9. SAVE ANALYSIS RESULTS
    // ===========================
    console.log('\n9Ô∏è‚É£ SAVING ANALYSIS RESULTS')
    console.log('===========================')
    
    // Save detailed JSON report
    fs.writeFileSync('database-complete-analysis.json', JSON.stringify(analysis, null, 2))
    console.log('‚úÖ Detailed analysis saved to: database-complete-analysis.json')
    
    // Save human-readable report
    const report = generateHumanReport(analysis)
    fs.writeFileSync('COMPLETE-DATABASE-ANALYSIS.md', report)
    console.log('‚úÖ Human-readable report saved to: COMPLETE-DATABASE-ANALYSIS.md')
    
    console.log('\nüéâ COMPLETE DATABASE ANALYSIS FINISHED')
    console.log('======================================')

  } catch (error) {
    console.error('üí• Analysis failed:', error.message)
    analysis.error = error.message
  }
  
  return analysis
}

function generateHumanReport(analysis) {
  const timestamp = new Date().toISOString()
  
  return `# COMPLETE SUPABASE DATABASE ANALYSIS
**Generated:** ${timestamp}
**Connection:** ${analysis.connection.status}
**Database URL:** ${analysis.connection.url}

## üìä TABLE INVENTORY

### Existing Tables:
${Object.entries(analysis.tables).map(([name, info]) => 
  `- **${name}**: ${info.row_count} rows | RLS: ${analysis.policies[name]?.rls_enabled ? 'üîí Enabled' : 'üîì Disabled'}`
).join('\n')}

### Missing Critical Tables:
${analysis.missing_tables.length > 0 ? 
  analysis.missing_tables.map(name => `- ‚ùå **${name}** - Required for core functionality`).join('\n') :
  '‚úÖ All critical tables exist'
}

## üîí SECURITY STATUS

### Row Level Security (RLS):
${Object.entries(analysis.policies).map(([table, policy]) => 
  `- **${table}**: ${policy.rls_enabled ? 'üîí ENABLED' : 'üîì DISABLED'}`
).join('\n')}

## üìà DATA SUMMARY

### Current Data Counts:
${Object.entries(analysis.data_counts).map(([table, count]) => 
  `- **${table}**: ${count} records`
).join('\n')}

## üö® CRITICAL RECOMMENDATIONS

${analysis.recommendations.map(rec => `- ${rec}`).join('\n')}

## üìã NEXT STEPS

1. **Create missing tables** using migration scripts
2. **Enable RLS** on all tables for security
3. **Test service role bypass** for admin operations
4. **Verify data integrity** after changes
5. **Update application code** to use new tables

---
*Analysis completed successfully. Ready for table creation phase.*`
}

// Execute the analysis
analyzeCompleteDatabase()
  .then(result => {
    console.log('\nüìã Analysis Summary:')
    console.log(`- Tables found: ${Object.keys(result.tables).length}`)
    console.log(`- Missing tables: ${result.missing_tables.length}`)
    console.log(`- Recommendations: ${result.recommendations.length}`)
  })
  .catch(error => {
    console.error('üí• Complete analysis failed:', error)
  })